# PLL configuration program by Fabian Hövel, June 2022.
# This file accesses the MCP2210-API from Microchip and reads data from text files generated by TI's "TICS Pro" software in order to configure PLL chips.
# It works with TI's LMX249x series. Other PLL chips can be configured as well, as long the communication protocol and the structure of the text files is the same.

print("PLL configuration tool for TI's LMX249x series by Fabian Hövel, June 2022.")
print("Reads out data from 'HexRegisterValues.txt' and it writes all the registers inside the PLL chip.")

import pandas as pd

def read_file():
    #file = pd.read_csv(r'C:\Users\CMOS-PCB\OneDrive - tu-braunschweig.de\Documents\pythonproject\PLLconf\HexRegisterValues.txt', sep='\t', header = None)
    file = pd.read_csv(r'.\ControllPLL\HexRegisterValues.txt', sep='\t', header = None)
    adr = file[0].to_numpy()
    data = file[1].to_numpy()
    payload = len(data)*[0]
    for j in range(len(adr)):
        payload[j] = int(data[j][2:], 16)
        print("ADR = %3d"%(int(adr[j][1:])), " Data = %3d"%(payload[j] & 0x0000FF))
    return payload


#########################################################################################
#                                                                                       #
# ©2015 Microchip Technology Inc.and its subsidiaries.You may use this software and any #
# derivatives exclusively with Microchip products.                                      #
#                                                                                       #
# THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".NO WARRANTIES, WHETHER EXPRESS,        #
# IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF     #
# NON - INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS     #
# INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR          #
# USE IN ANY APPLICATION.                                                               #
#                                                                                       #
# IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, INCIDENTAL  #
# OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED         #
# TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE            #
# POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.TO THE FULLEST EXTENT ALLOWED BY           #
# LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE    #
# WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO            #
# MICROCHIP FOR THIS SOFTWARE.                                                          #
#                                                                                       #
# MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE          #
# TERMS.                                                                                #
#                                                                                       #
#########################################################################################

# MCP2210 demo using unmanaged DLL from python.

# import the mcp2210 unmanaged DLL
from ctypes import *
mcp2210 = windll.LoadLibrary(".\ControllPLL\mcp2210_dll_um_x64.dll")

Mcp2210_GetLibraryVersion       = mcp2210.Mcp2210_GetLibraryVersion
Mcp2210_GetLastError            = mcp2210.Mcp2210_GetLastError
Mcp2210_GetConnectedDevCount    = mcp2210.Mcp2210_GetConnectedDevCount
Mcp2210_OpenByIndex             = mcp2210.Mcp2210_OpenByIndex
Mcp2210_Close                   = mcp2210.Mcp2210_Close
Mcp2210_GetManufacturerString   = mcp2210.Mcp2210_GetManufacturerString
Mcp2210_GetProductString        = mcp2210.Mcp2210_GetProductString
Mcp2210_GetSerialNumber         = mcp2210.Mcp2210_GetSerialNumber

Mcp2210_OpenByIndex.restype = c_void_p

#Fur Datenübermittlung
Mcp2210_GetSpiConfig            = mcp2210.Mcp2210_GetSpiConfig
Mcp2210_SetSpiConfig            = mcp2210.Mcp2210_SetSpiConfig
Mcp2210_GetGpioConfig           = mcp2210.Mcp2210_GetGpioConfig
Mcp2210_SetGpioConfig           = mcp2210.Mcp2210_SetGpioConfig
Mcp2210_xferSpiData             = mcp2210.Mcp2210_xferSpiData
Mcp2210_xferSpiDataEx           = mcp2210.Mcp2210_xferSpiDataEx
Mcp2210_SetGpioPinDir           = mcp2210.Mcp2210_SetGpioPinDir
Mcp2210_SetGpioPinVal           = mcp2210.Mcp2210_SetGpioPinVal



#VID and PID of the MCP2210 devices
vid = c_ushort(0x4d8)
pid = c_ushort(0xde)

#error codes dictionary
errors_dict = {    0:'E_SUCCESS',                             -1:'E_ERR_UNKOWN_ERROR',            -2:'E_ERR_INVALID_PARAMETER',\
                 -10:'E_ERR_NULL',                           -20:'E_ERR_MALLOC',                 -30:'E_ERR_INVALID_HANDLE_VALUE',\
                -100:'E_ERR_FIND_DEV',                      -101:'E_ERR_NO_SUCH_INDEX',         -103:'E_ERR_DEVICE_NOT_FOUND',\
                -104:'E_ERR_INTERNAL_BUFFER_TOO_SMALL',     -105:'E_ERR_OPEN_DEVICE_ERROR',     -106:'E_ERR_CONNECTION_ALREADY_OPENED',\
                -107:'E_ERR_CLOSE_FAILED',                  -108:'E_ERR_NO_SUCH_SERIALNR',      -110:'E_ERR_HID_RW_TIMEOUT',\
                -111:'E_ERR_HID_RW_FILEIO',                 -200:'E_ERR_CMD_FAILED',            -201:'E_ERR_CMD_ECHO',\
                -202:'E_ERR_SUBCMD_ECHO',                   -203:'E_ERR_SPI_CFG_ABORT',         -204:'E_ERR_SPI_EXTERN_MASTER',\
                -205:'E_ERR_SPI_TIMEOUT',                   -206:'E_ERR_SPI_RX_INCOMPLETE',     -207:'E_ERR_SPI_XFER_ONGOING',\
                -300:'E_ERR_BLOCKED_ACCESS',                -301:'E_ERR_EEPROM_WRITE_FAIL',     -350:'E_ERR_NVRAM_LOCKED',\
                -351:'E_ERR_WRONG_PASSWD',                  -352:'E_ERR_ACCESS_DENIED',         -353:'E_ERR_NVRAM_PROTECTED',\
                -354:'E_ERR_PASSWD_CHANGE',                 -400:'E_ERR_STRING_DESCRIPTOR',     -401:'E_ERR_STRING_TOO_LARGE'    }



#######################################################################################
# SPI transfer function definition
#######################################################################################
def spi_xfer_data(par_txmsg):

    #start communnication
    pdataTx1[0] = (par_txmsg >> 16) & 0x00FF
    pdataTx1[1] = (par_txmsg >> 8 ) & 0x00FF
    pdataTx1[2] = (par_txmsg >> 0 ) & 0x00FF

    ret_code = Mcp2210_xferSpiData(handle0, pdataTx1, pdataRx1, byref(pbaudRate1), byref(ptxferSize1), csmask)
    print("RETMSG after xferSpiData = ",ret_code)

    # for j in range(len(pdataRx1)):
    #     print("RX"+str(j)+" = ", pdataRx1[j])
    # print("\nENDE")

    return

# print the welcome message and DLL version
version = create_unicode_buffer(32)   #version buffer size must be 64bytes (32 unicode characters)
  
ret_code = Mcp2210_GetLibraryVersion(version)
if ret_code == -10:
    print("Ooops...null pointer detected!!. Exiting...")
    exit()
else:
    print ("List MCP2210 devices using MCP2210 unmanaged DLL version ", version.value)


# detect the number of mcp2210 connected devices
print ("Counting the MCP2210 devices (with VID:0x%4.4X, PID:0x%4.4X):" % (vid.value, pid.value))
ret_code = Mcp2210_GetConnectedDevCount(vid, pid)
if ret_code < 0:
    print("Ooops...error code returned: ", errors_dict.get(ret_code, ret_code), ". Exiting...")
    exit()
else:
    print("Detected: ", ret_code)

# if no device detected, exit the application
if ret_code == 0:
    print("No device was detected...Bye!")
    exit()

dev_count = ret_code


print("\nMCP2210 #: ", 0 ," Who connects two of them at the same time???")
# Open the device with index #idx
index = c_uint32(0)
path = create_unicode_buffer(1)     #fake path buffer - first "open" call will return the needed size
pathsize = c_ulong(1)              #insufficient size provisioned in order to obtain the needed size

handle0 = c_void_p(Mcp2210_OpenByIndex(vid, pid, index, path, byref(pathsize)));
ret_code = Mcp2210_GetLastError()
if ret_code != -3:  #E_ERR_BUFFER_TOO_SMALL
    print("\nUnexpected error code returned: ", errors_dict.get(ret_code, ret_code), ". Exiting...")
    exit()

del path
path = create_unicode_buffer(int(pathsize.value/sizeof(c_wchar)))
handle0 = c_void_p(Mcp2210_OpenByIndex(vid, pid, index, path, byref(pathsize)));
ret_code = Mcp2210_GetLastError()
if ret_code != 0: #E_SUCCESS
    print("\nUnexpected error code returned: ", errors_dict.get(ret_code, ret_code), ". Exiting...")
    exit()
else:
    print ("\t-the path is: ", path.value)

# print the manufacturer descriptor
manufacturer = create_unicode_buffer(30)    #descriptor length is max 30 unicode characters including NULL terminator
ret_code = Mcp2210_GetManufacturerString(handle0, manufacturer)
if ret_code != 0: #E_SUCCESS
    print("Unexpected error code returned: ", errors_dict.get(ret_code, ret_code))
else:
    print ("\t-the manufacturer descriptor is: ", manufacturer.value)

# print the product descriptor
product = create_unicode_buffer(30)    #descriptor length is max 30 unicode characters including NULL terminator
ret_code = Mcp2210_GetProductString(handle0, product)
if ret_code != 0: #E_SUCCESS
    print("Unexpected error code returned: ", errors_dict.get(ret_code, ret_code))
else:
    print ("\t-the product descriptor is: ", product.value)

# print the serial number
productSN = create_unicode_buffer(30)    #descriptor length is max 30 unicode characters including NULL terminator
ret_code = Mcp2210_GetSerialNumber(handle0, productSN)
if ret_code != 0: #E_SUCCESS
    print("Unexpected error code returned: ", errors_dict.get(ret_code, ret_code))
else:
    print ("\t-the product Serial Number is: ", productSN.value)

#eigener Schiss
#Hier findet zunächst die Konfiguration des MCP2210 statt.
err_code = 0                # return error code
cfgsel = c_ubyte(0)         # config selector - 0=VM, 1=NVRAM
nrpages = 8                 # EEPROM pages to access
pagesize = 16               # EEPROM page size
# the size of the following buffers should be at least nrpages*pagesize + 2
bufsz = 3#nrpages*pagesize + 2
pdataTx1 = (c_ubyte*bufsz)()  # SPI Tx data buffer
pdataRx1 = (c_ubyte*bufsz)()  # SPI Rx data buffer
# pdataRx2 = (c_ubyte*bufsz)()  # SPI Rx data buffer
# pdataRx3 = create_string_buffer(bufsz)

#set the device SPI config    
pbaudRate1      = c_uint(25000)
pidleCsVal1     = c_uint(0x1ff)
pactiveCsVal1   = c_uint(0x1ef) # GP4 active low CS
pcsToDataDly1   = c_uint(1)
pdataToDataDly1 = c_uint(0)
pdataToCsDly1   = c_uint(1)
ptxferSize1     = c_uint(3)
pspiMd1         = c_ubyte(0)
csmask          = c_uint(0x10)  # set GP4 as CS


#save the device GPIO config
#gpio designation: Set GP4 as Chip select, else as GPIO
gpio_des1   = (c_ubyte*9)(0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00)     
gpio_out1   = c_uint(0xFFFE)    #alle Pins auf High setzen, nur GP0 auf 0
gpio_dir1   = c_uint(0xFFEE)    #GP4 und GP0 auf Output
wkup1       = c_ubyte(0)        # irgendeine Wakeupfunktion
intmdcnt1   = c_ubyte(0)        #keine interrupts von Inputs
spibusen1   = c_ubyte(0)


#set the GPIO config
err_code = Mcp2210_SetGpioConfig(handle0, cfgsel, gpio_des1, gpio_out1, \
                                    gpio_dir1, wkup1, intmdcnt1, spibusen1)
print("ERRMSG after SetGPIOConfig = ",err_code)

#set SPI-Config
err_code = Mcp2210_SetSpiConfig(handle0, cfgsel, byref(pbaudRate1), byref(pidleCsVal1), \
                        byref(pactiveCsVal1), byref(pcsToDataDly1), byref(pdataToCsDly1), byref(pdataToDataDly1), \
                        byref(ptxferSize1), byref(pspiMd1))
print("ERRMSG after SetSPIConfig = ",err_code)


# while input("r -> read file. Else: -> quit program. Type in: ") == 'r':
print("Reading file.")
print("Reading file.")
payload = read_file()
for j in range(len(payload)):
    spi_xfer_data(payload[j])
#eigener Schiss Ende

# close the MCP2210 device with index #idx
ret_code = Mcp2210_Close(handle0)
if ret_code != 0: #E_SUCCESS
    print("Unexpected error code returned: ", errors_dict.get(ret_code, ret_code), ". Exiting...")
    exit()
print("Successfully closed!")
